# 跨設備棋盤同步測試指南

## 實現概述

已完成跨設備棋盤同步功能的實現。以下是實現的關鍵組件：

### 1. 前端移動發送 (src/app.ts)
- 玩家在本地棋盤上移動棋子時，會發送 `move` 消息到服務器
- 消息格式：
  ```json
  {
    "type": "move",
    "data": {
      "from": "(file, rank)",
      "to": "(file, rank)"
    }
  }
  ```

### 2. 服務器廣播 (server/src/server.ts)
- 服務器接收 `move` 消息後，廣播 `move_made` 消息給所有連接的客戶端
- 消息格式：
  ```json
  {
    "type": "move_made",
    "data": {
      "playerId": "client_id",
      "from": "(file, rank)",
      "to": "(file, rank)",
      "timestamp": 1234567890
    }
  }
  ```

### 3. 前端接收和應用 (src/app.ts)
- WebSocket 客戶端註冊 `move_made` 消息處理器
- 接收到遠程移動時，調用 `applyRemoteMove()` 函數
- `applyRemoteMove()` 函數：
  1. 解析位置字符串 (格式: "(file, rank)")
  2. 獲取要移動的棋子
  3. 執行移動（更新棋盤狀態）
  4. 切換當前玩家
  5. 檢測新玩家是否被將軍
  6. 清除選中狀態
  7. 更新信息顯示
  8. 重新渲染棋盤

## 測試步驟

### 前置條件
- 確保 Vercel 部署已完成（https://yuyan-chess.vercel.app）
- 確保 Railway 服務器已部署（wss://yuyan.up.railway.app）
- 兩個不同的設備或瀏覽器窗口

### 測試流程

1. **打開兩個瀏覽器窗口**
   - 窗口 A：https://yuyan-chess.vercel.app
   - 窗口 B：https://yuyan-chess.vercel.app

2. **在兩個窗口中開始遊戲**
   - 點擊「線上對決」按鈕
   - 兩個窗口都應該連接到服務器

3. **測試移動同步**
   - 在窗口 A 中移動一個紅方棋子
   - 驗證：
     - 窗口 A 中棋子立即移動
     - 窗口 B 中棋子也應該移動
     - 當前玩家應該切換到黑方
     - 兩個窗口的棋盤狀態應該一致

4. **測試多個移動**
   - 在窗口 B 中移動一個黑方棋子
   - 驗證：
     - 窗口 B 中棋子立即移動
     - 窗口 A 中棋子也應該移動
     - 當前玩家應該切換回紅方
     - 棋子計數應該正確更新

5. **檢查控制台日誌**
   - 打開瀏覽器開發者工具（F12）
   - 查看控制台日誌，應該看到：
     - `[遠程移動] (file, rank) -> (file, rank)` 消息
     - `[遠程移動] 已應用: 紅/黑方 ...` 消息

## 預期結果

✅ 兩個設備上的棋盤應該始終保持同步
✅ 移動應該立即在兩個設備上反映
✅ 當前玩家指示器應該正確更新
✅ 棋子計數應該正確
✅ 控制台應該沒有錯誤

## 故障排除

### 問題：移動不同步
- 檢查 WebSocket 連接是否建立（查看控制台日誌）
- 檢查 Railway 服務器是否在線
- 檢查瀏覽器控制台是否有錯誤

### 問題：棋盤狀態不一致
- 刷新頁面重新連接
- 檢查服務器日誌是否有錯誤

### 問題：移動被拒絕
- 確保只有當前玩家可以移動
- 檢查移動是否符合象棋規則

## 已部署的文件

- 前端：https://yuyan-chess.vercel.app
- 後端：wss://yuyan.up.railway.app
- 源代碼：https://github.com/yhy12721-taroflame/yuyan-chess

## 實現細節

### 位置字符串格式
- 格式：`(file, rank)`
- 例如：`(3, 4)` 表示第 3 列第 4 行
- 使用正則表達式解析：`/\((\d+),\s*(\d+)\)/`

### 消息流程
1. 玩家在窗口 A 移動棋子
2. 窗口 A 發送 `move` 消息到服務器
3. 服務器接收並廣播 `move_made` 消息給所有客戶端
4. 窗口 A 和 B 都接收 `move_made` 消息
5. 兩個窗口都調用 `applyRemoteMove()` 更新棋盤

### 錯誤處理
- 如果位置字符串格式無效，會記錄錯誤
- 如果源位置沒有棋子，會記錄錯誤並返回
- 所有錯誤都會被捕獲並記錄到控制台

